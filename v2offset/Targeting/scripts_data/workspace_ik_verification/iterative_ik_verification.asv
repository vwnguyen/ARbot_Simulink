% attempt to find the catching line for the robot
% loads the robot and plots its path along a set trajectory


%% load model 
close all 
robot=importrobot('ARbot_Rev2_1.urdf');
% load robot
newPose = robot.randomConfiguration;
% Add another massless coordinate frame for the end effector
eeOffset = 0.150;
eeBody = robotics.RigidBody('end_effector');
eeBody.Mass = 0;
eeBody.Inertia = [0 0 0 0 0 0];
setFixedTransform(eeBody.Joint,trvec2tform([eeOffset 0 0]));
figure(1);
addBody(robot,eeBody,'L4');
axes = show(robot,robot.homeConfiguration);
axes.CameraPositionMode = 'auto';
%% 

base_to_catch_out = [  0.0000    0.9397   -0.3420;
   -1.0000    0.0000         0;
         0    0.3420    0.9397];
ROTZ = rotz( 90 ); 
rotation_matrix = base_to_catch_out;
     
T_A_B = [ 0 0 0 0;
  0 0 0 0;
  0 0 0 0;
  0 0 0 1;
  ];

%% old catching line ( NOT FLIPPED ) 
P_A_BORG_65 = [ 0.2205 0.5588 -0.3135];
P_A_BORG_75 = [0.5024 0.5588 -0.2109];
P_A_BORG_8 = [0.6434 0.5588 -0.1596];
P_A_BORG_9 = [0.9253 0.5588 -0.0570];

% FLIP X AND Y TO ACCOUNT FOR MATLAB REFERENCE FRAME
P_A_BORG_65 = [ -0.5588 -0.2205 -0.3135];
P_A_BORG_75= [-0.5588 -0.5024 -0.2109]; % 2nd furthest 9.75
P_A_BORG_8 = [ -0.5588; -0.6434; -0.1596 ]; % furthest from the robot 9.8
P_A_BORG_9 = [ -0.5588; -0.9253; -0.0570 ]; % furthest from the robot 9.9

% corners for the end point

%% 75
P_B = [ 0; 0; 0; 1;];
T_A_B(1:3,1:3) = base_to_catch_out;
T_A_B(1:3,4) = P_A_BORG_75;
P_A = T_A_B * P_B; % vector from the base of the robot to the target
angleInRadians = deg2rad(-70);
% get joint angles for each point
P_end = P_A;
P_end(1) = -P_end(1);
P_mid_75 = midpoint(P_A,P_end);

%% 8
P_B = [ 0; 0; 0; 1;];
T_A_B(1:3,1:3) = base_to_catch_out;
T_A_B(1:3,4) = P_A_BORG_8;
P_A = T_A_B * P_B; % vector from the base of the robot to the target
angleInRadians = deg2rad(-70);
% get joint angles for each point
P_end = P_A;
P_end(1) = -P_end(1);
P_mid_8 = midpoint(P_A,P_end);

%% 9
P_B = [ 0; 0; 0; 1;];
T_A_B(1:3,1:3) = base_to_catch_out;
T_A_B(1:3,4) = P_A_BORG_9;
P_A = T_A_B * P_B; % vector from the base of the robot to the target
angleInRadians = deg2rad(-70);
% get joint angles for each point
P_end = P_A;
P_end(1) = -P_end(1);
P_mid_9 = midpoint(P_A,P_end);
%%

wayPoints = [ P_A_BORG_65(1) P_A_BORG_65(2) P_A_BORG_65(3);
   -P_A_BORG_65(1) P_A_BORG_65(2) P_A_BORG_65(3);
   
      P_mid_75;
      P_mid_8;
      P_mid_9;] ;
exampleHelperPlotWaypoints(wayPoints)
hold on

% create line to add points to
h1 = animatedline('LineWidth',5,'Color','r');
pos = [];
end_effector_pos = [];

%% Perform Inverse Kinematics No Constraints
% Use desired weights for solution (First three are orientation, last three are translation)
% Since it is a 4-DOF robot with only one revolute joint in Z we do not
% put a weight on Z rotation; otherwise it limits the solution space

ik = robotics.InverseKinematics('RigidBodyTree',robot);
weights = [0.1 0.1 0 1 1 1];
initialguess = robot.homeConfiguration;

% Call inverse kinematics solver for every end-effector position using the
% previous configuration as initial guess
for idx = 1:size(wayPoints,1)
    tform = trvec2tform(wayPoints(idx,:));
    configSoln(idx,:) = ik('end_effector',tform,weights,initialguess);
    initialguess = configSoln(idx,:);
end

%% Visualize robot configurations
title('Robot waypoint tracking visualization')
for idx = 1:size(wayPoints,1)
    % figure(idx);
    show(robot,configSoln(idx,:), 'PreservePlot', true,'Frames','off');
    pause(0.1)
    hold on
end

%% Perform Inverse Kinematics With Constraints

% constraints:
%     Start in the home configuration
% 
%     No abrupt changes in robot configuration
% 
%     Keep the gripper at least 5 cm above the "table" (z = 0)
% 
%     The gripper should be aligned with the target as it approaches
% 
%     Finish with the gripper 5 cm from the center of the target

q0 = homeConfiguration(robot);
numwayPoints = length(wayPoints);
qWaypoints = repmat(q0, numWaypoints, 1);

gik = generalizedInverseKinematics('RigidBodyTree', robot, ...
    'ConstraintInputs', {'cartesian','position','aiming','orientation','joint'})

%% constrain height to 0.05 cm above target

heightAboveTable = constraintCartesianBounds('end_effector');
heightAboveTable.Bounds = [-inf, inf; ...
                           -inf, inf; ...
                           0.05, inf];

%% constrain position of end effector relative to gripper

% add a body to robot model representing waypoint
body = rigidBody('targetFrame');
setFixedTransform(body.Joint, trvec2tform(P_A_BORG_65))
addBody(robot, body, robot.BaseName);

% constrain position of target relative to the gripper with tolerance of
% 0.005

distanceFromtarget = constraintPositionTarget('targetFrame');
distanceFromtarget.ReferenceBody = 'end_effector';
distanceFromtarget.PositionTolerance = 0.005;


% requires the z-axis of the ee frame to be approximately 
% vertical, by placing the target far above the robot.
alignWithTarget = constraintAiming('end_effector');
alignWithTarget.TargetPoint = [0, 0, 100];

%% limit changes in joint configurations

limitJointChange = constraintJointBounds(lbr)

%% create orientation constraint for gripper with tolerance of 1 degree

fixOrientation = constraintOrientationTarget('end_effector');
fixOrientation.OrientationTolerance = deg2rad(-70)

%% Functions

function rot_z = rotz(ang)

    rot_z = [ cosd(ang) -sind(ang) 0;
    sin(ang) cos(ang) 0 ;
    0 0 1;];
end

function P_mid = midpoint(P1,P2)
    P_mid(1) = (P1(1) + P2(1)) / 2;
    P_mid(2) = (P1(2) + P2(2)) / 2;
    P_mid(3) = (P1(3) + P2(3)) / 2;
end